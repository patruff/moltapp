---
phase: 01-identity-and-wallets
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - package.json
  - src/services/wallet.ts
  - src/services/deposit.ts
  - src/routes/auth.ts
  - src/routes/wallets.ts
  - src/routes/webhooks.ts
  - src/index.ts
autonomous: true
user_setup:
  - service: turnkey
    why: "Custodial Solana wallet creation and transaction signing via TEE"
    env_vars:
      - name: TURNKEY_API_PRIVATE_KEY
        source: "Turnkey Dashboard -> Developers -> API Keys -> Create API Key (download private key)"
      - name: TURNKEY_API_PUBLIC_KEY
        source: "Turnkey Dashboard -> Developers -> API Keys -> Create API Key (copy public key)"
      - name: TURNKEY_ORGANIZATION_ID
        source: "Turnkey Dashboard -> Settings -> Organization ID"
  - service: helius
    why: "Deposit detection via webhooks (push-based, parsed Solana transactions)"
    env_vars:
      - name: HELIUS_API_KEY
        source: "Helius Dashboard -> API Keys"
      - name: HELIUS_WEBHOOK_SECRET
        source: "Generate a random secret (e.g., openssl rand -hex 32) and use it when creating the Helius webhook"
  - service: solana
    why: "RPC access for balance queries and transaction submission"
    env_vars:
      - name: SOLANA_RPC_URL
        source: "Helius RPC URL (included with Helius plan) or other Solana RPC provider. Use devnet URL for development."

must_haves:
  truths:
    - "New agent registration automatically creates a Turnkey-managed Solana wallet"
    - "Agent can query their SOL and USDC balance via GET /api/v1/wallet/balance"
    - "SOL or USDC sent to agent deposit address is detected and recorded via Helius webhook"
  artifacts:
    - path: "src/services/wallet.ts"
      provides: "Turnkey wallet creation abstraction"
      contains: "createWallet"
    - path: "src/services/deposit.ts"
      provides: "Deposit processing with idempotency"
      contains: "txSignature"
    - path: "src/routes/wallets.ts"
      provides: "Wallet balance endpoint"
      exports: ["walletRoutes"]
    - path: "src/routes/webhooks.ts"
      provides: "Helius webhook handler for deposit detection"
      contains: "nativeTransfers"
  key_links:
    - from: "src/routes/auth.ts"
      to: "src/services/wallet.ts"
      via: "calls createAgentWallet during registration"
      pattern: "createAgentWallet"
    - from: "src/routes/wallets.ts"
      to: "@solana/kit"
      via: "queries on-chain balance via RPC"
      pattern: "getBalance"
    - from: "src/routes/webhooks.ts"
      to: "src/services/deposit.ts"
      via: "processes Helius webhook events into deposit records"
      pattern: "recordDeposit"
    - from: "src/services/deposit.ts"
      to: "src/db/schema/transactions.ts"
      via: "inserts deposit with txSignature as idempotency key"
      pattern: "transactions"
---

<objective>
Wire up Turnkey custodial wallet creation into agent registration, add balance query endpoints, and implement Helius webhook-based deposit detection. After this plan, agents get wallets on registration, can check balances, and deposits are automatically detected.

Purpose: Wallets are the core asset container. Without them, agents cannot hold funds, and without deposit detection, agents cannot fund their wallets. This unlocks the funding flow.

Output: Turnkey wallet service, wallet creation wired into /auth/register, GET /api/v1/wallet and GET /api/v1/wallet/balance endpoints, POST /webhooks/helius deposit handler.
</objective>

<execution_context>
@/Users/patruff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patruff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-identity-and-wallets/01-RESEARCH.md
@.planning/phases/01-identity-and-wallets/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Turnkey wallet service and wallet creation in registration flow</name>
  <files>
    package.json
    src/services/wallet.ts
    src/routes/auth.ts
    src/routes/wallets.ts
    src/index.ts
  </files>
  <action>
    1. Install Turnkey and Solana packages:
       ```
       npm install @turnkey/sdk-server @turnkey/solana @solana/kit @solana-program/system @solana/spl-token
       ```

    2. Create src/services/wallet.ts:
       - Initialize Turnkey client:
         ```typescript
         import { Turnkey } from '@turnkey/sdk-server';
         const turnkey = new Turnkey({
           apiBaseUrl: 'https://api.turnkey.com',
           apiPrivateKey: env.TURNKEY_API_PRIVATE_KEY,
           apiPublicKey: env.TURNKEY_API_PUBLIC_KEY,
           defaultOrganizationId: env.TURNKEY_ORGANIZATION_ID,
         });
         const client = turnkey.apiClient();
         ```
       - Export `createAgentWallet(agentId: string): Promise<{ publicKey: string, turnkeyWalletId: string }>`:
         a. Call `client.createWallet()` with walletName `moltapp-agent-${agentId}`, one account with curve ED25519, path "m/44'/501'/0'/0'", addressFormat SOLANA
         b. Extract the Solana public key (base58) from the response
         c. Return `{ publicKey, turnkeyWalletId }`
       - Export `getTurnkeySigner()` that returns a `TurnkeySigner` instance (will be used by Plan 03 for withdrawals)
       - Handle Turnkey errors gracefully: wrap in try/catch, throw descriptive errors like "wallet_creation_failed"

    3. Update src/routes/auth.ts (the register endpoint from Plan 01):
       - After upserting the agent profile, check if agent already has a wallet (query wallets table by agentId)
       - If no wallet exists:
         a. Call `createAgentWallet(agent.id)` from wallet service
         b. Insert into `wallets` table: agentId, publicKey, turnkeyWalletId
       - Include `walletAddress` in the registration response:
         ```json
         { "agentId": "...", "apiKey": "mk_...", "walletAddress": "...", "profile": { ... } }
         ```
       - If wallet already exists, return the existing walletAddress

    4. Create src/routes/wallets.ts:
       - Create a Hono sub-app: `const walletRoutes = new Hono()`
       - GET / (wallet info):
         a. Get agentId from `c.get('agentId')` (set by auth middleware)
         b. Query wallets table by agentId
         c. If no wallet found, return 404 `{ error: "wallet_not_found" }`
         d. Return 200 `{ agentId, walletAddress: wallet.publicKey, createdAt: wallet.createdAt }`
       - GET /balance:
         a. Get agent's wallet publicKey from DB
         b. Query SOL balance via `@solana/kit` RPC: `rpc.getBalance(address(publicKey)).send()`
         c. Query USDC balance: derive the ATA address for the USDC mint + wallet address, call `rpc.getTokenAccountBalance(ataAddress).send()`. Wrap in try/catch -- if ATA doesn't exist, USDC balance is 0.
         d. Return 200:
            ```json
            {
              "sol": { "lamports": "1000000000", "display": "1.000000000" },
              "usdc": { "rawAmount": "1000000", "display": "1.000000" }
            }
            ```
         e. Use `decimal.js` for display formatting (not floating point division)
       - Create a helper to get the Solana RPC client (use env.SOLANA_RPC_URL)
       - Export `walletRoutes`

    5. Update src/index.ts:
       - Import and mount walletRoutes at `/api/v1/wallet` (behind auth + rate limit middleware)
  </action>
  <verify>
    1. `npm run build` compiles without errors
    2. Server starts without crashing (with Turnkey env vars set)
    3. POST /api/v1/auth/register (with valid Moltbook token) returns response including `walletAddress` field
    4. GET /api/v1/wallet returns wallet info for authenticated agent
    5. GET /api/v1/wallet/balance returns SOL and USDC balance structure
  </verify>
  <done>
    Registration creates a Turnkey-managed Solana wallet. Wallet info and balance endpoints work. WALL-01 (custodial wallet creation) and WALL-03 (balance query) are implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Helius webhook handler for deposit detection</name>
  <files>
    src/services/deposit.ts
    src/routes/webhooks.ts
    src/index.ts
  </files>
  <action>
    1. Create src/services/deposit.ts:
       - Export `processDeposit(params: { agentId: string, type: 'SOL' | 'USDC', amount: string, txSignature: string, timestamp: number }): Promise<void>`:
         a. Check if txSignature already exists in transactions table (idempotency guard)
         b. If exists, log "Duplicate deposit ignored" and return (do NOT throw)
         c. If new, insert into transactions table: agentId, type='deposit', tokenType=params.type, amount (convert lamports to SOL or raw USDC to decimal using decimal.js), txSignature, status='confirmed', createdAt, confirmedAt
         d. Use a try/catch around the insert -- if unique constraint violation on txSignature, treat as duplicate (race condition safety)
       - Export `findAgentByWalletAddress(walletAddress: string): Promise<{ id: string } | null>`:
         a. Query wallets table where publicKey = walletAddress
         b. Return { id: wallet.agentId } or null

    2. Create src/routes/webhooks.ts:
       - Create a Hono sub-app: `const webhookRoutes = new Hono()`
       - POST /helius:
         a. Verify webhook authenticity: check Authorization header matches `Bearer ${env.HELIUS_WEBHOOK_SECRET}`. If not, return 401.
         b. Parse body as JSON array of transaction events
         c. For each event:
            - Process `nativeTransfers` array (SOL deposits):
              For each transfer, call `findAgentByWalletAddress(transfer.toUserAccount)`
              If agent found, call `processDeposit({ agentId, type: 'SOL', amount: transfer.amount.toString(), txSignature: event.signature, timestamp: event.timestamp })`
            - Process `tokenTransfers` array (USDC deposits):
              For each transfer where `transfer.mint === USDC_MINT` (use the correct mint for current network from constants):
              Call `findAgentByWalletAddress(transfer.toUserAccount)`
              If agent found, call `processDeposit({ agentId, type: 'USDC', amount: transfer.tokenAmount.toString(), txSignature: event.signature, timestamp: event.timestamp })`
         d. Return 200 `{ received: true }` (always return 200 to prevent Helius retries, even if individual deposits fail -- log errors instead)
       - Export `webhookRoutes`

    3. Update src/index.ts:
       - Import and mount webhookRoutes at `/webhooks` (NOT behind auth middleware -- webhooks use their own auth via the secret header)

    Important notes:
    - The Helius webhook handler must be idempotent (same event processed twice produces same result)
    - Use USDC_MINT_DEVNET for development, USDC_MINT_MAINNET for production (select based on NODE_ENV or a SOLANA_NETWORK env var)
    - Amount conversion: SOL nativeTransfer amounts are in lamports (divide by 1e9). USDC tokenTransfer amounts may already be in token units -- check Helius docs. Use decimal.js for all conversions.
    - Always return 200 to Helius. Log errors internally. Failed processing should not cause webhook retries that could lead to duplicate processing.
  </action>
  <verify>
    1. `npm run build` compiles without errors
    2. `curl -X POST http://localhost:3000/webhooks/helius -H "Authorization: Bearer wrong" -d '[]'` returns 401
    3. `curl -X POST http://localhost:3000/webhooks/helius -H "Authorization: Bearer ${HELIUS_WEBHOOK_SECRET}" -H "Content-Type: application/json" -d '[]'` returns 200 `{"received":true}`
    4. Sending a mock Helius event with a nativeTransfer to a known agent wallet address creates a record in the transactions table
  </verify>
  <done>
    Helius webhook handler processes SOL and USDC deposit events, records them in the transactions table with idempotency protection, and returns 200 to prevent retries. WALL-02 (deposit detection) is implemented.
  </done>
</task>

</tasks>

<verification>
- TypeScript compiles without errors (`npm run build`)
- Registration response includes walletAddress
- GET /api/v1/wallet returns wallet info
- GET /api/v1/wallet/balance returns SOL and USDC balance
- Helius webhook endpoint rejects unauthorized requests
- Helius webhook endpoint processes deposit events idempotently
- Transactions table records deposits with unique txSignature constraint
</verification>

<success_criteria>
1. Agent registration creates a Turnkey wallet and returns the wallet address (WALL-01)
2. GET /api/v1/wallet/balance returns on-chain SOL and USDC balances (WALL-03)
3. POST /webhooks/helius processes deposit events and records them in DB (WALL-02)
4. Duplicate webhook events do not create duplicate transaction records
5. All endpoints compile and respond correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-identity-and-wallets/01-02-SUMMARY.md`
</output>

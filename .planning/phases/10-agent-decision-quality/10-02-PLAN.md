---
phase: 10-agent-decision-quality
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/services/decision-quality-dashboard.ts
autonomous: true

must_haves:
  truths:
    - "Decision quality report aggregates all existing quality services"
    - "Composite score is computed with weighted dimensions"
    - "Quality snapshots are stored for trend analysis"
  artifacts:
    - path: "src/services/decision-quality-dashboard.ts"
      provides: "Unified quality aggregation service"
      exports: ["generateDecisionQualityReport", "getLatestQualitySnapshot", "storeQualitySnapshot", "DecisionQualityReport"]
  key_links:
    - from: "src/services/decision-quality-dashboard.ts"
      to: "src/services/confidence-calibration-analyzer.ts"
      via: "function import"
      pattern: "analyzeCalibration|getCalibrationAnalysis"
    - from: "src/services/decision-quality-dashboard.ts"
      to: "src/services/reasoning-integrity-engine.ts"
      via: "function import"
      pattern: "generateIntegrityReport"
    - from: "src/services/decision-quality-dashboard.ts"
      to: "src/services/tool-use-quality-analyzer.ts"
      via: "function import"
      pattern: "analyzeToolUseQuality"
---

<objective>
Create the unified decision quality dashboard service that consolidates all existing quality services.

Purpose: MoltApp has 5+ quality services (calibration, integrity, accountability, memory, now tool-use) but no single view. This service orchestrates all of them and produces a unified DecisionQualityReport with a composite score. This is the "aggregation layer" identified as missing in the research.

Output: Single service that produces comprehensive quality reports by calling existing services in parallel and computing weighted composite scores.
</objective>

<execution_context>
@/Users/patruff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patruff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-agent-decision-quality/10-RESEARCH.md
@.planning/phases/10-agent-decision-quality/10-01-SUMMARY.md

# Existing services to aggregate
@src/services/confidence-calibration-analyzer.ts
@src/services/reasoning-integrity-engine.ts
@src/services/decision-accountability-tracker.ts
@src/services/cross-session-memory-analyzer.ts
@src/services/tool-use-quality-analyzer.ts
@src/db/schema/decision-quality.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create decision quality dashboard service</name>
  <files>src/services/decision-quality-dashboard.ts</files>
  <action>
Create `src/services/decision-quality-dashboard.ts` implementing:

**Main Interface:**
```typescript
interface DecisionQualityReport {
  agentId: string;
  timestamp: string;
  // From existing services
  calibration: {
    ece: number;
    grade: string;
    overconfidenceRatio: number;
  };
  integrity: {
    integrityScore: number;
    flipFlops: number;
    contradictions: number;
  };
  accountability: {
    accountabilityScore: number;
    accuracyRate: number;
    totalClaims: number;
  };
  memory: {
    memoryScore: number;
    trend: "improving" | "stable" | "declining";
  };
  toolUse: {
    correctnessScore: number;
    sequenceAdherence: number;
    violations: string[];
  };
  // Composite
  compositeScore: number;
  grade: string;
  strengths: string[];
  weaknesses: string[];
}
```

**Functions:**
1. `generateDecisionQualityReport(agentId: string): Promise<DecisionQualityReport>`
   - Call all 5 services in parallel with Promise.all:
     - `analyzeCalibration(agentId)` from confidence-calibration-analyzer
     - `generateIntegrityReport(agentId)` from reasoning-integrity-engine
     - `getAccountabilityProfile(agentId)` from decision-accountability-tracker
     - `getAgentMemoryProfile(agentId)` from cross-session-memory-analyzer
     - `analyzeToolUseQuality(agentId)` from tool-use-quality-analyzer
   - Compute composite score using weights from research:
     - calibration: 0.20 (use 1 - ECE since lower ECE is better)
     - integrity: 0.20
     - accountability: 0.20
     - memory: 0.15
     - toolUse: 0.25
   - Derive grade from composite score
   - Identify top 2 strengths (highest dimension scores)
   - Identify top 2 weaknesses (lowest dimension scores)

2. `storeQualitySnapshot(report: DecisionQualityReport): Promise<void>`
   - Insert into decisionQualitySnapshots table
   - Generate id as `quality_${agentId}_${Date.now()}`

3. `getLatestQualitySnapshot(agentId: string): Promise<DecisionQualityReport | null>`
   - Query decisionQualitySnapshots for most recent
   - Return null if no snapshots exist

4. `computeGrade(score: number): string`
   - A+ >= 0.95, A >= 0.90, A- >= 0.85, B+ >= 0.80, B >= 0.75, B- >= 0.70
   - C+ >= 0.65, C >= 0.60, C- >= 0.55, D >= 0.50, F < 0.50

**Handle missing data gracefully:**
- If any service returns no data (new agent), use default score of 0.5 for that dimension
- Log warning but don't fail the report generation

**Follow patterns from:**
- `orchestrator.ts` for parallel Promise.all calls
- `llm-cost-tracker.ts` for service structure
  </action>
  <verify>
`npx tsc --noEmit` passes with no errors.
Service exports all 4 functions.
Imports from all 5 quality services compile correctly.
  </verify>
  <done>Service exports generateDecisionQualityReport, storeQualitySnapshot, getLatestQualitySnapshot. TypeScript compiles. All imports resolve.</done>
</task>

<task type="auto">
  <name>Task 2: Add quality report generation to heartbeat integration point</name>
  <files>src/services/decision-quality-dashboard.ts</files>
  <action>
Add a batch function to the service:

```typescript
/**
 * Generate and store quality reports for all active agents.
 * Call this from heartbeat after trading rounds complete.
 */
export async function generateAllQualityReports(): Promise<{
  generated: number;
  agents: string[];
}> {
  // Get list of active agents from agents table
  const activeAgents = await db
    .select({ id: agents.id })
    .from(agents)
    .where(eq(agents.status, "active"));

  const agentIds = activeAgents.map(a => a.id);
  const results: string[] = [];

  for (const agentId of agentIds) {
    try {
      const report = await generateDecisionQualityReport(agentId);
      await storeQualitySnapshot(report);
      results.push(agentId);
    } catch (err) {
      console.warn(`Failed to generate quality report for ${agentId}:`, err);
    }
  }

  return { generated: results.length, agents: results };
}
```

This allows heartbeat to call `generateAllQualityReports()` after trading rounds to update quality snapshots. The actual heartbeat integration is deferred - this just exposes the capability.
  </action>
  <verify>
`npx tsc --noEmit` passes.
grep "generateAllQualityReports" src/services/decision-quality-dashboard.ts returns match.
  </verify>
  <done>Batch function exists and exports. TypeScript compiles.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - zero TypeScript errors
2. Service imports from all 5 quality analyzers
3. All exports available: generateDecisionQualityReport, storeQualitySnapshot, getLatestQualitySnapshot, generateAllQualityReports
4. Test: Import service in a scratch file and verify types
</verification>

<success_criteria>
- Service file exists at src/services/decision-quality-dashboard.ts
- Imports all 5 existing quality services
- Exports DecisionQualityReport type and 4 functions
- Composite score calculation uses correct weights
- TypeScript compilation: 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-agent-decision-quality/10-02-SUMMARY.md`
</output>

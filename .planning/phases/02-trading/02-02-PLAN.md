---
phase: 02-trading
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/services/jupiter.ts
  - src/services/stocks.ts
  - src/services/trading.ts
  - src/routes/stocks.ts
  - src/routes/trading.ts
  - src/routes/positions.ts
  - src/routes/trades.ts
  - src/index.ts
autonomous: true
user_setup:
  - service: jupiter
    why: "Jupiter Ultra API requires API key for all endpoints"
    env_vars:
      - name: JUPITER_API_KEY
        source: "Sign up at portal.jup.ag -> copy API key"

must_haves:
  truths:
    - "Agent can list all available tokenized stocks with current prices via GET /api/v1/stocks"
    - "Agent can buy a tokenized stock at market price via POST /api/v1/trading/buy and see holding in positions"
    - "Agent can sell a tokenized stock via POST /api/v1/trading/sell and see USDC returned"
    - "Agent can view current stock positions via GET /api/v1/positions"
    - "Agent can view trade history with timestamps, prices, and amounts via GET /api/v1/trades"
  artifacts:
    - path: "src/services/jupiter.ts"
      provides: "Jupiter Ultra API client: getOrder, executeOrder, getPrices, signJupiterTransaction"
      min_lines: 80
    - path: "src/services/stocks.ts"
      provides: "Stock catalog lookup and price enrichment: getStockBySymbol, getStockByMint, listStocksWithPrices"
      min_lines: 40
    - path: "src/services/trading.ts"
      provides: "Trade execution orchestrator: executeBuy, executeSell with validation, Jupiter flow, DB recording, position update"
      min_lines: 120
    - path: "src/routes/stocks.ts"
      provides: "GET /api/v1/stocks (list all with prices), GET /api/v1/stocks/:symbol (single stock)"
      exports: ["stockRoutes"]
    - path: "src/routes/trading.ts"
      provides: "POST /api/v1/trading/buy, POST /api/v1/trading/sell"
      exports: ["tradingRoutes"]
    - path: "src/routes/positions.ts"
      provides: "GET /api/v1/positions"
      exports: ["positionRoutes"]
    - path: "src/routes/trades.ts"
      provides: "GET /api/v1/trades"
      exports: ["tradeRoutes"]
    - path: "src/index.ts"
      provides: "All new routes mounted after auth middleware"
      contains: "tradingRoutes"
  key_links:
    - from: "src/routes/trading.ts"
      to: "src/services/trading.ts"
      via: "executeBuy/executeSell function calls"
      pattern: "execute(Buy|Sell)"
    - from: "src/services/trading.ts"
      to: "src/services/jupiter.ts"
      via: "getOrder + signJupiterTransaction + executeOrder calls"
      pattern: "(getOrder|executeOrder|signJupiterTransaction)"
    - from: "src/services/trading.ts"
      to: "src/db/schema/trades.ts"
      via: "db.insert(trades) after confirmed execution"
      pattern: "db\\.insert\\(trades\\)"
    - from: "src/services/trading.ts"
      to: "src/db/schema/positions.ts"
      via: "upsert position after trade confirmation"
      pattern: "(positions|onConflictDoUpdate)"
    - from: "src/services/jupiter.ts"
      to: "src/services/wallet.ts"
      via: "getTurnkeySigner for transaction signing"
      pattern: "getTurnkeySigner"
    - from: "src/routes/stocks.ts"
      to: "src/services/stocks.ts"
      via: "listStocksWithPrices for price-enriched listing"
      pattern: "listStocksWithPrices"
    - from: "src/index.ts"
      to: "src/routes/trading.ts"
      via: "app.route mounting"
      pattern: "app\\.route.*trading"
---

<objective>
Build the complete trading feature: Jupiter API integration, stock discovery with prices, trade execution (buy/sell), position tracking, and trade history.

Purpose: This is the core Phase 2 deliverable. After this plan, agents can discover stocks, execute trades, and track their portfolio -- satisfying all four TRAD requirements.

Output: 4 new service/route files, updated index.ts with route mounting. Complete buy/sell flow: validate -> Jupiter order -> Turnkey sign -> Jupiter execute -> record trade -> update position.
</objective>

<execution_context>
@/Users/patruff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patruff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-trading/02-CONTEXT.md
@.planning/phases/02-trading/02-RESEARCH.md
@.planning/phases/02-trading/02-01-SUMMARY.md

@src/index.ts
@src/config/constants.ts
@src/config/env.ts
@src/db/index.ts
@src/db/schema/index.ts
@src/services/wallet.ts
@src/services/withdrawal.ts
@src/routes/wallets.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Jupiter API client and stock catalog service</name>
  <files>src/services/jupiter.ts, src/services/stocks.ts</files>
  <action>
Create `src/services/jupiter.ts` -- Jupiter Ultra API client with Turnkey signing bridge:

**Imports:**
- `{ env }` from `../config/env.ts`
- `{ JUPITER_API_BASE_URL }` from `../config/constants.ts`
- `{ getTurnkeySigner }` from `./wallet.ts`

**Functions to implement:**

1. `getOrder(params: { inputMint: string; outputMint: string; amount: string; taker: string }): Promise<JupiterOrderResponse>`
   - GET `${JUPITER_API_BASE_URL}/ultra/v1/order` with params as query string
   - Include `x-api-key: env.JUPITER_API_KEY` header
   - Return typed response: `{ transaction: string; requestId: string; inAmount: string; outAmount: string; swapType: string; slippageBps: number }`
   - If response is not ok or `transaction` is missing, throw with Jupiter error details

2. `signJupiterTransaction(base64Transaction: string, walletAddress: string): Promise<string>`
   - Decode base64 to Uint8Array using `Buffer.from(base64Transaction, 'base64')`
   - Parse Solana wire format to extract message bytes:
     - First byte = compact-u16 number of signers (for < 128 signers, this is just 1 byte)
     - Skip `numSigners * 64` bytes of signature placeholders
     - Everything after = messageBytes
   - Sign messageBytes using `getTurnkeySigner().signMessage(new Uint8Array(messageBytes), walletAddress)` -- same pattern as Phase 1 withdrawal.ts `signWithTurnkey`
   - Inject signature into first slot of the original transaction bytes (at offset after the compact-u16 byte)
   - Return `Buffer.from(signedTx).toString('base64')`
   - CRITICAL: Do NOT modify the transaction in any other way. Jupiter explicitly prohibits this.

3. `executeOrder(params: { signedTransaction: string; requestId: string }): Promise<JupiterExecuteResponse>`
   - POST `${JUPITER_API_BASE_URL}/ultra/v1/execute`
   - Headers: `Content-Type: application/json`, `x-api-key: env.JUPITER_API_KEY`
   - Body: `{ signedTransaction, requestId }`
   - Return typed response: `{ status: string; signature: string; code: number; slot?: number; inputAmountResult?: string; outputAmountResult?: string; swapEvents?: unknown[] }`
   - If status is not "Success", throw descriptive error with the code and details
   - Handle polling: if code is -1006 (timeout), retry the same request once after 2 seconds

4. `getPrices(mintAddresses: string[]): Promise<Record<string, JupiterPrice | null>>`
   - GET `${JUPITER_API_BASE_URL}/price/v3?ids=${mintAddresses.join(',')}`
   - Include `x-api-key` header
   - Return map of mintAddress to `{ usdPrice: number; blockId: string; decimals: number; priceChange24h: number } | null`
   - Handle up to 50 mints per request (batch if needed, though 20 catalog tokens fits in one request)

**Types to define (export):**
- `JupiterOrderResponse` -- fields from getOrder
- `JupiterExecuteResponse` -- fields from executeOrder
- `JupiterPrice` -- fields from price response

---

Create `src/services/stocks.ts` -- Stock catalog service with price enrichment:

**Imports:**
- `{ XSTOCKS_CATALOG, StockToken }` from `../config/constants.ts`
- `{ getPrices }` from `./jupiter.ts`

**Functions to implement:**

1. `getStockBySymbol(symbol: string): StockToken | undefined`
   - Case-insensitive lookup against XSTOCKS_CATALOG
   - Return the matching StockToken or undefined

2. `getStockByMint(mintAddress: string): StockToken | undefined`
   - Lookup against XSTOCKS_CATALOG by mintAddress
   - Return the matching StockToken or undefined

3. `listStocksWithPrices(): Promise<StockWithPrice[]>`
   - Get all mint addresses from XSTOCKS_CATALOG
   - Call `getPrices(mintAddresses)` to fetch current USD prices
   - Merge catalog data with price data
   - Return array of `{ symbol, name, mintAddress, decimals, usdPrice: number | null, priceChange24h: number | null }`
   - If Jupiter price API fails, return catalog with null prices (graceful degradation, do NOT throw)

**Types to define (export):**
- `StockWithPrice` -- StockToken extended with usdPrice and priceChange24h (both nullable)
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Verify that jupiter.ts exports getOrder, signJupiterTransaction, executeOrder, getPrices. Verify that stocks.ts exports getStockBySymbol, getStockByMint, listStocksWithPrices.
  </verify>
  <done>Jupiter Ultra API client handles full order->sign->execute flow with Turnkey signing bridge (wire format byte parsing, same pattern as Phase 1). Stock catalog service provides symbol/mint lookups and price-enriched listings from Jupiter Price API V3.</done>
</task>

<task type="auto">
  <name>Task 2: Trading execution service with position management</name>
  <files>src/services/trading.ts</files>
  <action>
Create `src/services/trading.ts` -- Trade execution orchestrator:

**Imports:**
- `{ Decimal }` from `decimal.js` (named import, NOT default -- per Phase 1 ESM compatibility decision)
- `{ db }` from `../db/index.ts`
- `{ trades, positions, wallets }` from `../db/schema/index.ts`
- `{ eq, and, sql }` from `drizzle-orm`
- `{ getOrder, signJupiterTransaction, executeOrder }` from `./jupiter.ts`
- `{ getStockBySymbol }` from `./stocks.ts`
- `{ USDC_MINT_MAINNET, USDC_MINT_DEVNET }` from `../config/constants.ts`
- `{ env }` from `../config/env.ts`
- `{ createSolanaRpc, address, getAddressEncoder, getProgramDerivedAddress }` from `@solana/kit`

**Helper:**
- `getUsdcMint(): string` -- returns USDC_MINT_MAINNET in production, USDC_MINT_DEVNET otherwise (same pattern as wallets.ts)
- `getSolanaRpc()` -- same pattern as wallets.ts

**Types (export):**
```typescript
interface TradeRequest {
  agentId: string;
  stockSymbol: string;
  usdcAmount: string;  // For buys: USDC to spend. For sells: ignored.
  stockQuantity?: string; // For sells: quantity to sell. For buys: ignored.
}

interface TradeResult {
  tradeId: number;
  txSignature: string;
  status: string;
  side: 'buy' | 'sell';
  stockSymbol: string;
  stockQuantity: string;
  usdcAmount: string;
  pricePerToken: string;
}
```

**Function: `executeBuy(req: TradeRequest): Promise<TradeResult>`**

Step-by-step:
1. **Validate stock:** Look up `req.stockSymbol` via `getStockBySymbol`. If not found, throw `stock_not_found: {symbol} is not a supported stock`.
2. **Get wallet:** Query wallets table for req.agentId. If not found, throw `wallet_not_found`.
3. **Validate amount:** Parse req.usdcAmount with Decimal. Must be > 0 and have at most 6 decimal places. Convert to raw USDC units: `new Decimal(req.usdcAmount).mul(1e6).toFixed(0)`.
4. **Balance check:** Query on-chain USDC balance via RPC (derive ATA with SPL Token program for USDC, same as wallets.ts). Also check SOL balance >= 0.01 SOL (10_000_000 lamports) for transaction fees. If insufficient, throw `insufficient_usdc_balance` or `insufficient_sol_for_fees`.
5. **Jupiter order:** Call `getOrder({ inputMint: getUsdcMint(), outputMint: stock.mintAddress, amount: usdcRawAmount, taker: wallet.publicKey })`.
6. **Sign transaction:** Call `signJupiterTransaction(order.transaction, wallet.publicKey)`.
7. **Execute:** Call `executeOrder({ signedTransaction: signedBase64, requestId: order.requestId })`.
8. **Calculate trade details:**
   - `stockQuantity = new Decimal(result.outputAmountResult || order.outAmount).div(new Decimal(10).pow(stock.decimals))`
   - `usdcSpent = new Decimal(req.usdcAmount)`
   - `pricePerToken = usdcSpent.div(stockQuantity)`
9. **Record trade in DB:** Insert into trades table with all fields. Use db.insert(trades).values({...}).returning() to get the trade ID.
10. **Update position:** Upsert into positions table:
    - If position exists for (agentId, mintAddress): increment quantity, recalculate averageCostBasis using weighted average: `newAvgCost = ((oldQty * oldAvgCost) + (newQty * pricePerToken)) / (oldQty + newQty)`, update updatedAt.
    - If position doesn't exist: insert new row with quantity and averageCostBasis = pricePerToken.
    - Use `db.insert(positions).values({...}).onConflictDoUpdate({ target: [positions.agentId, positions.mintAddress], set: { quantity: sql`...`, averageCostBasis: sql`...`, updatedAt: new Date() } })`.
    - For the weighted average SQL: `quantity = positions.quantity + excluded.quantity` and `average_cost_basis = ((positions.quantity * positions.average_cost_basis) + (excluded.quantity * excluded.average_cost_basis)) / (positions.quantity + excluded.quantity)`.
11. **Return TradeResult.**

**Function: `executeSell(req: TradeRequest): Promise<TradeResult>`**

Step-by-step:
1. **Validate stock:** Same as buy.
2. **Get wallet:** Same as buy.
3. **Validate quantity:** Parse req.stockQuantity with Decimal. Must be > 0.
4. **Position check:** Query positions table for (agentId, mintAddress). If no position or quantity < requested, throw `insufficient_stock_balance`.
5. **Convert to raw units:** `rawStockAmount = new Decimal(req.stockQuantity).mul(new Decimal(10).pow(stock.decimals)).toFixed(0)`.
6. **Jupiter order:** Call `getOrder({ inputMint: stock.mintAddress, outputMint: getUsdcMint(), amount: rawStockAmount, taker: wallet.publicKey })`. For sells, the input is the stock token and output is USDC.
7. **Balance check:** Check SOL >= 0.01 SOL for fees.
8. **Sign + Execute:** Same as buy.
9. **Calculate trade details:**
   - `stockQuantity = new Decimal(req.stockQuantity)` (what was sold)
   - `usdcReceived = new Decimal(result.outputAmountResult || order.outAmount).div(1e6)` (USDC received)
   - `pricePerToken = usdcReceived.div(stockQuantity)`
10. **Record trade in DB:** Insert into trades table with side='sell'.
11. **Update position:** Decrease quantity. If quantity reaches 0, delete the position row. Otherwise update quantity and updatedAt (averageCostBasis stays the same on sells).
    - `const newQuantity = new Decimal(existingPosition.quantity).minus(req.stockQuantity)`
    - If `newQuantity.lte(0)`: delete position row
    - Else: update position with new quantity
12. **Return TradeResult.**

**Error handling:** All errors thrown with descriptive prefixes (e.g., `stock_not_found:`, `jupiter_order_failed:`, `jupiter_execute_failed:`, `insufficient_usdc_balance:`, `insufficient_sol_for_fees:`). The route layer translates these to HTTP status codes.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Verify trading.ts exports executeBuy and executeSell. Verify it imports from jupiter.ts, stocks.ts, and the DB schema. Verify the position upsert logic handles both insert and update cases.
  </verify>
  <done>Trading service orchestrates the full buy/sell lifecycle: validate -> balance check -> Jupiter order -> Turnkey sign -> Jupiter execute -> record trade -> update position. Positions use weighted average cost basis on buy, quantity decrement on sell.</done>
</task>

<task type="auto">
  <name>Task 3: API routes and index.ts mounting</name>
  <files>src/routes/stocks.ts, src/routes/trading.ts, src/routes/positions.ts, src/routes/trades.ts, src/index.ts</files>
  <action>
Create `src/routes/stocks.ts` -- Stock discovery endpoints:

```typescript
import { Hono } from "hono";
import { listStocksWithPrices, getStockBySymbol } from "../services/stocks.ts";
import { getPrices } from "../services/jupiter.ts";

type StockEnv = { Variables: { agentId: string } };
export const stockRoutes = new Hono<StockEnv>();
```

1. **GET /** -- List all available stocks with current prices
   - Call `listStocksWithPrices()`
   - Return `{ stocks: StockWithPrice[] }` with 200
   - If Jupiter price API fails internally, stocks still return with null prices

2. **GET /:symbol** -- Single stock details with price
   - Get symbol from `c.req.param("symbol")`
   - Look up stock via `getStockBySymbol(symbol)`
   - If not found, return `{ error: "stock_not_found" }` with 404
   - Fetch price for that single mint via `getPrices([stock.mintAddress])`
   - Return `{ symbol, name, mintAddress, decimals, usdPrice, priceChange24h }` with 200

---

Create `src/routes/trading.ts` -- Buy and sell endpoints:

```typescript
import { Hono } from "hono";
import { z } from "zod";
import { executeBuy, executeSell } from "../services/trading.ts";

type TradingEnv = { Variables: { agentId: string } };
export const tradingRoutes = new Hono<TradingEnv>();
```

1. **POST /buy** -- Execute a buy trade
   - Validate body with zod: `{ stockSymbol: z.string().min(1), usdcAmount: z.string().regex(/^\d+(\.\d{1,6})?$/) }`
   - Call `executeBuy({ agentId: c.get("agentId"), stockSymbol, usdcAmount })`
   - On success: return TradeResult with 200
   - On error: parse error prefix to determine status code:
     - `stock_not_found` -> 404
     - `wallet_not_found` -> 404
     - `insufficient_usdc_balance` or `insufficient_sol_for_fees` or `insufficient_stock_balance` -> 400
     - `jupiter_order_failed` or `jupiter_execute_failed` -> 502 (upstream failure)
     - All others -> 500
   - Error response format: `{ error: errorPrefix, details: fullMessage }`

2. **POST /sell** -- Execute a sell trade
   - Validate body with zod: `{ stockSymbol: z.string().min(1), stockQuantity: z.string().regex(/^\d+(\.\d{1,9})?$/) }`
   - Call `executeSell({ agentId: c.get("agentId"), stockSymbol, stockQuantity })`
   - Same error handling pattern as /buy

---

Create `src/routes/positions.ts` -- Position viewing:

```typescript
import { Hono } from "hono";
import { eq } from "drizzle-orm";
import { db } from "../db/index.ts";
import { positions } from "../db/schema/index.ts";

type PositionEnv = { Variables: { agentId: string } };
export const positionRoutes = new Hono<PositionEnv>();
```

1. **GET /** -- List agent's current positions
   - Query: `db.select().from(positions).where(eq(positions.agentId, agentId))`
   - Return `{ positions: Array<{ symbol, mintAddress, quantity, averageCostBasis, updatedAt }> }` with 200
   - Empty array is valid (agent has no positions)

---

Create `src/routes/trades.ts` -- Trade history:

```typescript
import { Hono } from "hono";
import { eq, desc } from "drizzle-orm";
import { db } from "../db/index.ts";
import { trades } from "../db/schema/index.ts";

type TradesEnv = { Variables: { agentId: string } };
export const tradeRoutes = new Hono<TradesEnv>();
```

1. **GET /** -- List agent's trade history
   - Query: `db.select().from(trades).where(eq(trades.agentId, agentId)).orderBy(desc(trades.createdAt))`
   - Support optional query params: `?limit=50` (default 50, max 200) and `?offset=0`
   - Apply `.limit(limit).offset(offset)` to query
   - Return `{ trades: Array<{ id, side, stockSymbol, stockQuantity, usdcAmount, pricePerToken, txSignature, status, createdAt }> }` with 200

---

Update `src/index.ts` -- Mount all new routes:

Add imports for the 4 new route modules (after existing imports):
```typescript
import { stockRoutes } from "./routes/stocks.ts";
import { tradingRoutes } from "./routes/trading.ts";
import { positionRoutes } from "./routes/positions.ts";
import { tradeRoutes } from "./routes/trades.ts";
```

Mount new routes AFTER the existing `app.route("/api/v1/wallet", walletRoutes);` line (all protected by the existing auth middleware + rate limiter already applied to `/api/v1/*`):
```typescript
app.route("/api/v1/stocks", stockRoutes);
app.route("/api/v1/trading", tradingRoutes);
app.route("/api/v1/positions", positionRoutes);
app.route("/api/v1/trades", tradeRoutes);
```

Do NOT modify the existing middleware setup or route order. The existing `app.use("/api/v1/*", authMiddleware, agentRateLimiter)` already protects all `/api/v1/*` routes.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Verify all 4 route files export their named routes. Verify index.ts imports and mounts all 4 new routes after the auth middleware. Verify the complete route list:
- GET /api/v1/stocks -- list stocks with prices
- GET /api/v1/stocks/:symbol -- single stock detail
- POST /api/v1/trading/buy -- buy stock
- POST /api/v1/trading/sell -- sell stock
- GET /api/v1/positions -- list positions
- GET /api/v1/trades -- list trade history
  </verify>
  <done>All 4 route files created and mounted in index.ts. Stocks endpoint returns catalog with Jupiter prices. Trading endpoints validate input, delegate to trading service, translate errors to HTTP codes. Positions and trades endpoints query DB with agent filtering. All routes protected by existing auth middleware and rate limiter.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors across all new and existing files
2. Route structure is correct:
   - GET /api/v1/stocks -> 200 with stock list
   - GET /api/v1/stocks/:symbol -> 200 with single stock or 404
   - POST /api/v1/trading/buy -> 200 with trade result (requires Jupiter API key + funded wallet for actual execution)
   - POST /api/v1/trading/sell -> 200 with trade result
   - GET /api/v1/positions -> 200 with positions array
   - GET /api/v1/trades -> 200 with trades array
3. Jupiter signing bridge uses wire format byte parsing (same pattern as Phase 1 Turnkey signing)
4. Position upsert uses weighted average cost basis on buy
5. All routes are behind auth middleware (mounted after `app.use("/api/v1/*", ...)`)
</verification>

<success_criteria>
- Agent can GET /api/v1/stocks and receive all 20 xStocks with prices from Jupiter
- Agent can POST /api/v1/trading/buy with {stockSymbol, usdcAmount} and get confirmed trade result
- Agent can POST /api/v1/trading/sell with {stockSymbol, stockQuantity} and get confirmed trade result
- Agent can GET /api/v1/positions and see updated holdings after trades
- Agent can GET /api/v1/trades and see full history ordered by createdAt desc
- `npx tsc --noEmit` passes
- All routes protected by API key auth + rate limiting
</success_criteria>

<output>
After completion, create `.planning/phases/02-trading/02-02-SUMMARY.md`
</output>

---
phase: 04-aws-deployment
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - scripts/migrate-production.ts
autonomous: false

user_setup:
  - service: aws
    why: "CDK deployment target"
    env_vars:
      - name: AWS_ACCESS_KEY_ID
        source: "AWS IAM console -> Users -> Security credentials -> Create access key"
      - name: AWS_SECRET_ACCESS_KEY
        source: "AWS IAM console (same as above)"
    dashboard_config:
      - task: "Bootstrap CDK in us-east-1"
        location: "Terminal: cd infra && npx cdk bootstrap aws://ACCOUNT_ID/us-east-1"
      - task: "Populate Secrets Manager secret after first deploy"
        location: "AWS Console -> Secrets Manager -> moltapp/production -> Set secret value as JSON with keys: DATABASE_URL, MOLTBOOK_APP_KEY, JUPITER_API_KEY, ADMIN_PASSWORD, HELIUS_API_KEY, HELIUS_WEBHOOK_SECRET, SOLANA_RPC_URL, TURNKEY_API_PRIVATE_KEY, TURNKEY_API_PUBLIC_KEY, TURNKEY_ORGANIZATION_ID, APP_URL, NODE_ENV"
  - service: neon
    why: "Production PostgreSQL database"
    env_vars:
      - name: NEON_DATABASE_URL
        source: "Neon Console -> Project -> Connection Details -> Pooled connection string"
    dashboard_config:
      - task: "Create Neon project in AWS us-east-1"
        location: "Neon Console -> New Project"
      - task: "Copy pooled connection string (with -pooler suffix)"
        location: "Neon Console -> Connection Details -> Select Pooled"

must_haves:
  truths:
    - "Production migration script runs Drizzle migrations against Neon from a developer machine"
    - "After `cdk deploy`, the production URL (patgpt.us) responds to HTTP requests"
    - "API requests to production URL reach the Hono server and return correct responses"
    - "Application reads secrets from Secrets Manager (no .env in production)"
    - "Application connects to Neon PostgreSQL and serves data"
  artifacts:
    - path: "scripts/migrate-production.ts"
      provides: "Drizzle migration runner using Neon HTTP driver"
      contains: "migrate"
  key_links:
    - from: "scripts/migrate-production.ts"
      to: "@neondatabase/serverless"
      via: "neon() driver for Drizzle migrator"
      pattern: "neon.*DATABASE_URL"
    - from: "patgpt.us/health"
      to: "Lambda function"
      via: "CloudFront -> API Gateway -> Lambda"
      pattern: "status.*ok"
---

<objective>
Create the production database migration script and verify the full deployment works end-to-end: CDK deploy, Secrets Manager population, Neon migration, and production URL health check.

Purpose: This plan closes the loop on the deployment. Plan 01 made the app Lambda-ready, Plan 02 defined the infrastructure. This plan provides the migration tool and verifies everything works together in production.

Output: 1 migration script + verified production deployment.
</objective>

<execution_context>
@/Users/patruff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patruff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-aws-deployment/04-RESEARCH.md
@.planning/phases/04-aws-deployment/04-01-SUMMARY.md
@.planning/phases/04-aws-deployment/04-02-SUMMARY.md

@src/db/migrations/
@drizzle.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create production migration script</name>
  <files>scripts/migrate-production.ts</files>
  <action>
Create `scripts/migrate-production.ts` that runs Drizzle migrations against the production Neon database:

```typescript
// Usage: NEON_DATABASE_URL="postgresql://..." npx tsx scripts/migrate-production.ts
import { neon } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-http";
import { migrate } from "drizzle-orm/neon-http/migrator";

const databaseUrl = process.env.NEON_DATABASE_URL;
if (!databaseUrl) {
  console.error("NEON_DATABASE_URL environment variable is required");
  console.error("Usage: NEON_DATABASE_URL='postgresql://...' npx tsx scripts/migrate-production.ts");
  process.exit(1);
}

console.log("Connecting to Neon...");
const sql = neon(databaseUrl);
const db = drizzle({ client: sql });

console.log("Running migrations...");
await migrate(db, { migrationsFolder: "./src/db/migrations" });
console.log("Migration completed successfully");
```

This script:
- Reads NEON_DATABASE_URL from the environment (not from .env or Secrets Manager)
- Uses the Neon HTTP driver (same as Lambda production)
- Runs all pending Drizzle migrations from `./src/db/migrations/`
- Is run manually from a developer machine: `NEON_DATABASE_URL="..." npx tsx scripts/migrate-production.ts`
- process.exit(1) is fine here since this is a CLI script, not Lambda code
  </action>
  <verify>
Verify the script has no TypeScript errors: `npx tsc --noEmit scripts/migrate-production.ts` (or just verify the imports resolve). The script can't be fully tested without a Neon database URL, but the syntax and imports should be valid.
  </verify>
  <done>
`scripts/migrate-production.ts` exists and can run Drizzle migrations against any Neon PostgreSQL instance using the HTTP driver. Developer runs it with `NEON_DATABASE_URL=... npx tsx scripts/migrate-production.ts`.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete AWS deployment infrastructure: Lambda-ready app code (Plan 01), CDK infrastructure stack (Plan 02), and production migration script (this plan). The full deployment pipeline is:

1. `cd infra && npx cdk deploy` -- creates all AWS resources
2. Populate Secrets Manager secret in AWS Console with all env var values
3. `NEON_DATABASE_URL="..." npx tsx scripts/migrate-production.ts` -- runs DB migrations
4. Visit https://patgpt.us/health -- should return `{"status":"ok"}`
  </what-built>
  <how-to-verify>
**Pre-deployment setup (one-time):**
1. Ensure AWS CLI is configured with credentials for your account
2. Bootstrap CDK: `cd infra && npx cdk bootstrap aws://YOUR_ACCOUNT_ID/us-east-1`
3. Create Neon project at https://console.neon.tech (region: AWS us-east-1)
4. Note the pooled connection string from Neon dashboard

**Deploy:**
5. Run: `cd infra && npx cdk deploy`
6. Wait for deployment to complete (may take 5-10 minutes for CloudFront)

**Configure secrets:**
7. Go to AWS Console -> Secrets Manager -> moltapp/production
8. Set the secret value as JSON with all required keys:
   ```json
   {
     "DATABASE_URL": "(Neon pooled connection string)",
     "MOLTBOOK_APP_KEY": "(your Moltbook app key)",
     "JUPITER_API_KEY": "(your Jupiter API key)",
     "ADMIN_PASSWORD": "(your admin password)",
     "NODE_ENV": "production",
     "HELIUS_API_KEY": "(if configured)",
     "HELIUS_WEBHOOK_SECRET": "(if configured)",
     "SOLANA_RPC_URL": "(your Solana RPC URL)",
     "TURNKEY_API_PRIVATE_KEY": "(your Turnkey private key)",
     "TURNKEY_API_PUBLIC_KEY": "(your Turnkey public key)",
     "TURNKEY_ORGANIZATION_ID": "(your Turnkey org ID)",
     "APP_URL": "https://patgpt.us"
   }
   ```

**Run migrations:**
9. Run: `NEON_DATABASE_URL="(pooled connection string)" npx tsx scripts/migrate-production.ts`

**Verify:**
10. `curl https://patgpt.us/health` -- should return `{"status":"ok"}`
11. Visit https://patgpt.us in a browser -- should show the leaderboard page
12. `curl https://patgpt.us/api/v1/stocks` with a valid API key -- should return stock list from production DB

If CloudFront shows "403 Forbidden" or the leaderboard shows no data, check CloudWatch logs for the Lambda function.

**Post-deployment (manual):**
13. Configure Helius webhook to point to `https://patgpt.us/webhooks/helius`
  </how-to-verify>
  <resume-signal>Type "deployed" if production URL responds correctly, or describe any issues encountered.</resume-signal>
</task>

</tasks>

<verification>
1. `scripts/migrate-production.ts` exists and imports from `@neondatabase/serverless` and `drizzle-orm/neon-http/migrator`
2. Production URL (patgpt.us) returns `{"status":"ok"}` on `/health` (verified by user)
3. Production leaderboard page renders in browser (verified by user)
4. Secrets are read from Secrets Manager, not from .env (verified by Lambda logs in CloudWatch)
</verification>

<success_criteria>
- Production migration script can be run against Neon from developer machine
- `cdk deploy` creates all AWS resources successfully
- patgpt.us resolves to CloudFront which routes to API Gateway which invokes Lambda
- Lambda reads secrets from Secrets Manager and connects to Neon PostgreSQL
- All existing API endpoints and web pages work on the production URL
</success_criteria>

<output>
After completion, create `.planning/phases/04-aws-deployment/04-03-SUMMARY.md`
</output>

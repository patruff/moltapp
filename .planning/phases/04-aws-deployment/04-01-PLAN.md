---
phase: 04-aws-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app.ts
  - src/index.ts
  - src/lambda.ts
  - src/config/env.ts
  - src/db/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Local dev server still starts with `npm run dev` and responds at http://localhost:3000/health"
    - "Lambda entry point exports a `handler` function wrapping the same Hono app"
    - "In Lambda, secrets are fetched from AWS Secrets Manager on cold start before env validation"
    - "In Lambda, database queries use Neon HTTP driver instead of pg Pool"
    - "Local dev still uses pg Pool and .env file (no Neon/Secrets Manager dependency locally)"
  artifacts:
    - path: "src/app.ts"
      provides: "Shared Hono app with all route registrations"
      exports: ["default (app)"]
    - path: "src/lambda.ts"
      provides: "Lambda entry point using hono/aws-lambda handle()"
      exports: ["handler"]
    - path: "src/config/env.ts"
      provides: "Lambda-aware env loading with Secrets Manager fetch and throw instead of process.exit"
      contains: "loadSecretsFromAWS"
    - path: "src/db/index.ts"
      provides: "Conditional DB driver: Neon HTTP in Lambda, pg Pool locally"
      contains: "AWS_LAMBDA_FUNCTION_NAME"
  key_links:
    - from: "src/lambda.ts"
      to: "src/app.ts"
      via: "import default app"
      pattern: "import app from"
    - from: "src/index.ts"
      to: "src/app.ts"
      via: "import default app"
      pattern: "import app from"
    - from: "src/config/env.ts"
      to: "@aws-sdk/client-secrets-manager"
      via: "dynamic import in loadSecretsFromAWS"
      pattern: "import.*client-secrets-manager"
    - from: "src/db/index.ts"
      to: "@neondatabase/serverless"
      via: "dynamic import when AWS_LAMBDA_FUNCTION_NAME is set"
      pattern: "import.*@neondatabase/serverless"
---

<objective>
Make the existing MoltApp Hono server Lambda-compatible by extracting the shared app definition, creating a Lambda entry point, making environment loading async with Secrets Manager support, and swapping the database driver to Neon HTTP for Lambda.

Purpose: The app code must work in two modes -- local dev (serve + pg + .env) and Lambda (handle + Neon HTTP + Secrets Manager) -- using the same routes, middleware, and business logic. This is the app-side half of the deployment story.

Output: 5 modified/created source files + 2 new npm dependencies installed.
</objective>

<execution_context>
@/Users/patruff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patruff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-aws-deployment/04-RESEARCH.md

@src/index.ts
@src/config/env.ts
@src/db/index.ts
@package.json
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract shared Hono app and create dual entry points</name>
  <files>src/app.ts, src/index.ts, src/lambda.ts</files>
  <action>
1. Create `src/app.ts` by extracting the Hono app definition from `src/index.ts`:
   - Move all route imports (authRoutes, walletRoutes, webhookRoutes, stockRoutes, tradingRoutes, positionRoutes, tradeRoutes, leaderboardApiRoutes, pageRoutes) into app.ts
   - Move the `AppEnv` type definition into app.ts
   - Move all `app.get()`, `app.route()`, and `app.use()` calls into app.ts
   - Export the app as `export default app`
   - Do NOT import `serve` or `env` in app.ts -- those belong in the entry points
   - Import `authMiddleware` and `agentRateLimiter` in app.ts (they're middleware used in route registration)

2. Modify `src/index.ts` to become a thin local-dev entry point:
   - Remove all route imports (now in app.ts)
   - Import `app` from `./app.ts`
   - Import `serve` from `@hono/node-server`
   - Import `env` from `./config/env.ts`
   - Call `serve({ fetch: app.fetch, port: env.PORT }, ...)` (same as before)
   - Remove `export default app` (app is now exported from app.ts)

3. Create `src/lambda.ts` as the Lambda entry point:
   - Import `handle` from `hono/aws-lambda`
   - Import `app` from `./app.ts`
   - Export `const handler = handle(app)`
   - This file should be ~3 lines plus imports
  </action>
  <verify>
Run `npx tsx src/index.ts` and confirm the server starts and `curl http://localhost:3000/health` returns `{"status":"ok"}`. Then kill the server. Also verify `src/lambda.ts` has no TypeScript errors with `npx tsc --noEmit`.
  </verify>
  <done>
`src/app.ts` exports the shared Hono app with all routes. `src/index.ts` is a thin local-dev wrapper. `src/lambda.ts` exports a Lambda handler wrapping the same app. Local dev server starts and responds correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Make environment loading Lambda-aware with Secrets Manager</name>
  <files>src/config/env.ts, package.json</files>
  <action>
1. Install the Secrets Manager SDK:
   ```bash
   npm install @aws-sdk/client-secrets-manager
   ```

2. Modify `src/config/env.ts`:
   a. Replace `process.exit(1)` with `throw new Error(message)` in `loadEnv()`. The error message should include all Zod validation issue details (same format as current console.error output, but as a thrown error string).

   b. Add an async `loadSecretsFromAWS()` function:
      - Check `process.env.AWS_LAMBDA_FUNCTION_NAME` -- if not set, return immediately (local mode)
      - Use dynamic import: `const { SecretsManagerClient, GetSecretValueCommand } = await import("@aws-sdk/client-secrets-manager")`
      - Create client: `new SecretsManagerClient({})`
      - Fetch secret using `process.env.SECRET_ARN` as SecretId
      - Parse `response.SecretString` as JSON
      - Merge all key-value pairs into `process.env` using `Object.entries()` loop

   c. Add top-level await: `await loadSecretsFromAWS();` BEFORE the `export const env = loadEnv()` line

   d. Keep the `loadEnv()` function synchronous -- it just validates process.env with Zod after secrets are already loaded

   The env schema stays exactly the same. The Zod validation is unchanged. Only the loading mechanism and error handling change.
  </action>
  <verify>
Run `npx tsx src/index.ts` and confirm the server still starts (loadSecretsFromAWS should be a no-op locally since AWS_LAMBDA_FUNCTION_NAME is not set). Run `npx tsc --noEmit` to verify no type errors.
  </verify>
  <done>
`src/config/env.ts` fetches secrets from Secrets Manager when running in Lambda (detected via AWS_LAMBDA_FUNCTION_NAME), merges them into process.env, then validates with Zod. Locally, behavior is unchanged (reads .env). `process.exit(1)` replaced with `throw`.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add conditional Neon HTTP database driver for Lambda</name>
  <files>src/db/index.ts, package.json</files>
  <action>
1. Install the Neon serverless driver:
   ```bash
   npm install @neondatabase/serverless
   ```

2. Rewrite `src/db/index.ts` to use conditional driver loading:
   - Import `env` from `../config/env.ts` (keep this)
   - Import `* as schema` from `./schema/index.ts` (keep this)
   - Detect Lambda: `const isLambda = !!process.env.AWS_LAMBDA_FUNCTION_NAME`
   - Create an async `createDb()` function:
     - If `isLambda`:
       - Dynamic import `neon` from `@neondatabase/serverless`
       - Dynamic import `drizzle` from `drizzle-orm/neon-http`
       - Create: `const sql = neon(env.DATABASE_URL)`
       - Return: `drizzle({ client: sql })` (no schema parameter needed -- the codebase uses zero `db.query.*` relational queries)
     - Else (local):
       - Dynamic import `drizzle` from `drizzle-orm/node-postgres`
       - Dynamic import `pg` from `pg`
       - Create pool: `new pg.default.Pool({ connectionString: env.DATABASE_URL })`
       - Return: `drizzle(pool, { schema })`
   - Export: `export const db = await createDb()` (top-level await)

3. Remove the old static imports of `drizzle` and `pg` at the top of the file -- they're now dynamic.

4. Do NOT export the `pool` anymore -- it was only used internally. If any other file imports `pool`, search for it and remove those imports. (Research confirmed: no other files import pool.)

Important: The `drizzle-orm/neon-http` driver returns a slightly different type than `drizzle-orm/node-postgres`. All existing code uses `db.select()`, `db.insert()`, `db.update()`, `db.delete()` which are available on both. Do NOT use `db.query.*` relational queries -- the codebase has zero of them.
  </action>
  <verify>
Run `npx tsx src/index.ts` and confirm the local server starts with the pg driver (no AWS_LAMBDA_FUNCTION_NAME set). Test that a database query works by hitting an endpoint that reads from DB: `curl http://localhost:3000/health` (health check is DB-independent, but start the server to confirm no import errors). Run `npx tsc --noEmit` to verify no type errors.
  </verify>
  <done>
`src/db/index.ts` uses Neon HTTP driver when running in Lambda and pg Pool when running locally. Top-level await with dynamic imports. All existing code continues to work with both drivers since only `db.select/insert/update/delete` are used.
  </done>
</task>

</tasks>

<verification>
1. `npm run dev` starts the local server and responds to health check (proves local mode still works)
2. `npx tsc --noEmit` passes with zero errors (proves all TypeScript is valid)
3. `src/lambda.ts` exists and exports `handler` (proves Lambda entry point exists)
4. `src/config/env.ts` contains `loadSecretsFromAWS` and does NOT contain `process.exit` (proves Lambda-aware env loading)
5. `src/db/index.ts` contains `@neondatabase/serverless` in a dynamic import (proves conditional driver)
6. `package.json` has `@neondatabase/serverless` and `@aws-sdk/client-secrets-manager` in dependencies
</verification>

<success_criteria>
- App runs identically in local development (no behavioral changes)
- Lambda entry point wraps the exact same Hono app with all routes
- Environment loading detects Lambda and fetches from Secrets Manager before Zod validation
- Database driver selection is automatic based on runtime environment
- No `process.exit()` calls remain in the codebase
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-aws-deployment/04-01-SUMMARY.md`
</output>

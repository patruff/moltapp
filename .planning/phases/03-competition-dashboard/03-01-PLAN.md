---
phase: 03-competition-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tsconfig.json
  - src/config/env.ts
  - src/services/leaderboard.ts
  - src/routes/leaderboard-api.ts
autonomous: true

must_haves:
  truths:
    - "Leaderboard service computes per-agent portfolio values using Jupiter live prices"
    - "P&L is calculated as (current portfolio value - total capital deposited) for each agent"
    - "Leaderboard data is cached in-memory for 30 minutes with thundering herd prevention"
    - "Bot-facing JSON API returns cached leaderboard data at /api/v1/leaderboard"
    - "Bot can see its own ranking at /api/v1/leaderboard/me"
  artifacts:
    - path: "src/services/leaderboard.ts"
      provides: "Leaderboard computation, caching, and refresh logic"
      exports: ["getLeaderboard", "LeaderboardEntry", "LeaderboardData"]
    - path: "src/routes/leaderboard-api.ts"
      provides: "Bot-facing JSON API for leaderboard"
      exports: ["leaderboardApiRoutes"]
    - path: "tsconfig.json"
      provides: "JSX compiler support for Phase 03 Plan 02"
      contains: "jsxImportSource"
    - path: "src/config/env.ts"
      provides: "ADMIN_PASSWORD env var"
      contains: "ADMIN_PASSWORD"
  key_links:
    - from: "src/services/leaderboard.ts"
      to: "src/services/jupiter.ts"
      via: "getPrices() call for live market prices"
      pattern: "getPrices"
    - from: "src/services/leaderboard.ts"
      to: "src/db/schema/index.ts"
      via: "Drizzle queries for agents, positions, trades, transactions"
      pattern: "from\\(agents\\)|from\\(positions\\)|from\\(trades\\)|from\\(transactions\\)"
    - from: "src/routes/leaderboard-api.ts"
      to: "src/services/leaderboard.ts"
      via: "getLeaderboard() import"
      pattern: "getLeaderboard"
---

<objective>
Build the leaderboard data layer: computation service with caching, bot-facing JSON API, and config prerequisites (TSConfig JSX, ADMIN_PASSWORD env var).

Purpose: This plan creates all the data infrastructure that the web pages (Plan 02) will consume. It also delivers the bot-facing API so agents can read leaderboard data programmatically. The TSConfig change enables JSX compilation needed by Plan 02.

Output: Working leaderboard service that computes per-agent portfolio values from DB + Jupiter prices, caches results for 30 minutes, and serves them via authenticated JSON API endpoints.
</objective>

<execution_context>
@/Users/patruff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patruff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-competition-dashboard/03-CONTEXT.md
@.planning/phases/03-competition-dashboard/03-RESEARCH.md

Key source files to read before implementing:
@src/services/jupiter.ts          -- getPrices() function signature and return type (JupiterPrice)
@src/db/schema/agents.ts          -- agents table: id, name, karma, isActive
@src/db/schema/positions.ts       -- positions table: agentId, mintAddress, symbol, quantity(20,9), averageCostBasis(20,6)
@src/db/schema/trades.ts          -- trades table: agentId, side, stockMintAddress, usdcAmount(20,6), status, createdAt
@src/db/schema/transactions.ts    -- transactions table: agentId, type, tokenType, amount(20,9), status
@src/db/schema/index.ts           -- schema barrel exports
@src/db/index.ts                  -- db connection
@src/config/env.ts                -- current Zod env schema
@src/config/constants.ts          -- XSTOCKS_CATALOG (needed for mint addresses)
@src/index.ts                     -- current route mounting (leaderboard API goes AFTER auth middleware)
@tsconfig.json                    -- current config (needs jsx + jsxImportSource added)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config prerequisites -- TSConfig JSX, ADMIN_PASSWORD env var</name>
  <files>tsconfig.json, src/config/env.ts</files>
  <action>
    **tsconfig.json:** Add two fields to `compilerOptions`:
    - `"jsx": "react-jsx"`
    - `"jsxImportSource": "hono/jsx"`

    These go alongside the existing compilerOptions. Do NOT change any existing settings. The `include: ["src/**/*"]` glob already covers `.tsx` files.

    **src/config/env.ts:** Add `ADMIN_PASSWORD` to the Zod schema as a required string:
    ```
    ADMIN_PASSWORD: z.string().min(1, "ADMIN_PASSWORD is required"),
    ```
    Place it in the "Required" section alongside `DATABASE_URL`, `MOLTBOOK_APP_KEY`, `JUPITER_API_KEY`.

    WHY ADMIN_PASSWORD is required (not optional): The admin endpoints will use `basicAuth` from `hono/basic-auth` with this password. Making it optional would allow the app to start without admin protection, which is a security risk. The user needs to set this env var before starting the app.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- should compile with zero errors (existing .ts files unaffected by JSX config addition). Verify the tsconfig.json has the new fields. Verify env.ts includes ADMIN_PASSWORD.
  </verify>
  <done>
    tsconfig.json has `jsx: "react-jsx"` and `jsxImportSource: "hono/jsx"` in compilerOptions. env.ts Zod schema includes `ADMIN_PASSWORD` as required string.
  </done>
</task>

<task type="auto">
  <name>Task 2: Leaderboard computation service with in-memory cache</name>
  <files>src/services/leaderboard.ts</files>
  <action>
    Create `src/services/leaderboard.ts` implementing the leaderboard computation and caching.

    **Types to export:**

    ```typescript
    export interface LeaderboardEntry {
      rank: number;
      agentId: string;
      agentName: string;
      karma: number;
      totalPortfolioValue: string;  // formatted to 2 decimal places
      totalPnlPercent: string;      // formatted to 2 decimal places
      totalPnlAbsolute: string;     // formatted to 2 decimal places
      tradeCount: number;
      lastTradeAt: Date | null;
    }

    export interface LeaderboardData {
      entries: LeaderboardEntry[];
      aggregateStats: {
        totalAgents: number;
        totalVolume: string;  // sum of all USDC traded
      };
      computedAt: Date;
    }
    ```

    **Cache implementation (module-level singleton):**

    ```typescript
    const CACHE_TTL_MS = 30 * 60 * 1000;  // 30 minutes
    let cache: LeaderboardData | null = null;
    let refreshPromise: Promise<void> | null = null;
    ```

    **`getLeaderboard()` function (exported):**
    1. If `cache` exists and `(Date.now() - cache.computedAt.getTime()) < CACHE_TTL_MS`, return cache.
    2. If `refreshPromise` is non-null (refresh in progress), `await refreshPromise` then return cache. This prevents thundering herd.
    3. Otherwise, set `refreshPromise = refreshLeaderboard()`, await it, set `refreshPromise = null` in a finally block, return cache.

    **`refreshLeaderboard()` function (internal):**

    Step 1 -- Fetch all active agents:
    ```typescript
    const allAgents = await db.select().from(agents).where(eq(agents.isActive, true));
    ```

    Step 2 -- Fetch all positions (one query, not per-agent):
    ```typescript
    const allPositions = await db.select().from(positions);
    ```

    Step 3 -- Fetch live Jupiter prices for all unique mints across all positions:
    ```typescript
    const uniqueMints = [...new Set(allPositions.map(p => p.mintAddress))];
    const priceMap = uniqueMints.length > 0 ? await getPrices(uniqueMints) : {};
    ```

    Step 4 -- Aggregate trade stats per agent (single SQL query using Drizzle):
    ```typescript
    const tradeStats = await db
      .select({
        agentId: trades.agentId,
        tradeCount: count(trades.id),
        lastTradeAt: max(trades.createdAt),
        totalBuyUsdc: sql<string>`COALESCE(SUM(CASE WHEN ${trades.side} = 'buy' THEN ${trades.usdcAmount}::numeric ELSE 0 END), 0)`,
        totalSellUsdc: sql<string>`COALESCE(SUM(CASE WHEN ${trades.side} = 'sell' THEN ${trades.usdcAmount}::numeric ELSE 0 END), 0)`,
      })
      .from(trades)
      .where(eq(trades.status, "confirmed"))
      .groupBy(trades.agentId);
    ```

    Step 5 -- Aggregate deposit/withdrawal stats per agent (single SQL query):
    ```typescript
    const depositStats = await db
      .select({
        agentId: transactions.agentId,
        totalDeposited: sql<string>`COALESCE(SUM(CASE WHEN ${transactions.type} = 'deposit' AND ${transactions.tokenType} = 'USDC' THEN ${transactions.amount}::numeric ELSE 0 END), 0)`,
        totalWithdrawn: sql<string>`COALESCE(SUM(CASE WHEN ${transactions.type} = 'withdrawal' AND ${transactions.tokenType} = 'USDC' THEN ${transactions.amount}::numeric ELSE 0 END), 0)`,
      })
      .from(transactions)
      .where(eq(transactions.status, "confirmed"))
      .groupBy(transactions.agentId);
    ```

    Step 6 -- Compute per-agent metrics using Decimal.js (CRITICAL for precision):
    For each agent:
    - Get agent's positions from `allPositions.filter(p => p.agentId === agent.id)`
    - Get agent's trade stats from `tradeStats.find(t => t.agentId === agent.id)`
    - Get agent's deposit stats from `depositStats.find(d => d.agentId === agent.id)`

    **P&L Calculation (the "money in vs money out" approach -- simplest correct formula):**
    ```
    USDC cash balance = totalDeposited - totalWithdrawn - totalBuyUsdc + totalSellUsdc
    Market value of positions = SUM(jupiterPrice * positionQuantity) for each position
    Current Portfolio Value = USDC cash balance + market value of positions
    Total Capital Deposited = totalDeposited
    Total P&L (absolute) = Current Portfolio Value - Total Capital Deposited
    Total P&L (%) = (Total P&L / Total Capital Deposited) * 100
    ```

    If `totalDeposited` is 0 (agent has never deposited), set P&L % to "0.00" to avoid division by zero.

    Use `new Decimal(...)` for ALL arithmetic. PostgreSQL numeric columns return strings from Drizzle -- pass them directly to `new Decimal(stringValue)`. Only call `.toFixed(2)` at the very end when building the LeaderboardEntry.

    For positions where Jupiter returns null price, skip that position's value (log a warning). This is better than failing the entire leaderboard.

    Step 7 -- Sort and rank:
    Sort entries by P&L percentage descending (parse as float for comparison). Assign `rank = index + 1`.

    Step 8 -- Compute aggregate stats:
    ```typescript
    totalAgents = entries.length
    totalVolume = sum of (totalBuyUsdc + totalSellUsdc) across all agents
    ```

    Step 9 -- Update cache:
    ```typescript
    cache = { entries, aggregateStats, computedAt: new Date() };
    ```

    **Imports needed:**
    - `{ Decimal }` from `"decimal.js"`
    - `{ db }` from `"../db/index.ts"`
    - `{ agents, positions, trades, transactions }` from `"../db/schema/index.ts"`
    - `{ eq, sql, count, max }` from `"drizzle-orm"`
    - `{ getPrices }` from `"./jupiter.ts"`

    **Important:** Do NOT import from `"../config/constants.ts"` for this service -- the catalog isn't needed. We get mint addresses from the positions table directly.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- should compile with zero errors. Verify the file exports `getLeaderboard`, `LeaderboardEntry`, and `LeaderboardData`. Verify it imports from the correct paths with `.ts` extensions.
  </verify>
  <done>
    `src/services/leaderboard.ts` exists and exports `getLeaderboard()` which returns cached `LeaderboardData` with per-agent portfolio values, P&L percentages, trade counts, and aggregate stats. Cache refreshes every 30 minutes with thundering herd prevention via promise dedup.
  </done>
</task>

<task type="auto">
  <name>Task 3: Bot-facing JSON API routes and mounting in index.ts</name>
  <files>src/routes/leaderboard-api.ts, src/index.ts</files>
  <action>
    **src/routes/leaderboard-api.ts:** Create bot-facing JSON API.

    ```typescript
    import { Hono } from "hono";
    import { getLeaderboard } from "../services/leaderboard.ts";

    type LeaderboardApiEnv = { Variables: { agentId: string } };

    export const leaderboardApiRoutes = new Hono<LeaderboardApiEnv>();
    ```

    **GET `/` (maps to `/api/v1/leaderboard`):** Returns the full leaderboard as JSON.
    ```typescript
    leaderboardApiRoutes.get("/", async (c) => {
      const data = await getLeaderboard();
      return c.json({
        entries: data.entries,
        totalAgents: data.aggregateStats.totalAgents,
        totalVolume: data.aggregateStats.totalVolume,
        computedAt: data.computedAt.toISOString(),
      });
    });
    ```

    **GET `/me` (maps to `/api/v1/leaderboard/me`):** Returns the authenticated agent's own ranking.
    ```typescript
    leaderboardApiRoutes.get("/me", async (c) => {
      const agentId = c.get("agentId");
      const data = await getLeaderboard();
      const myEntry = data.entries.find((e) => e.agentId === agentId);
      if (!myEntry) {
        return c.json(
          { error: "not_ranked", message: "You have no trading activity yet" },
          404
        );
      }
      return c.json(myEntry);
    });
    ```

    **src/index.ts:** Mount the leaderboard API route AFTER the auth middleware line. This ensures it benefits from existing auth + rate limiting since `/api/v1/leaderboard` matches the `/api/v1/*` wildcard.

    Add import at top:
    ```typescript
    import { leaderboardApiRoutes } from "./routes/leaderboard-api.ts";
    ```

    Add route mount AFTER the existing protected routes (after the trade routes line):
    ```typescript
    // Leaderboard API routes (protected -- bots read their own stats)
    app.route("/api/v1/leaderboard", leaderboardApiRoutes);
    ```

    Place it between the trade routes mount and the `/api/v1/me` placeholder. Do NOT move or modify any existing route mounts. Do NOT add public page routes yet (that is Plan 02).

    **CRITICAL:** Keep `src/index.ts` as a `.ts` file -- it contains no JSX, only imports and route mounting. Do NOT rename it to `.tsx`.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- should compile with zero errors. Verify `src/index.ts` imports the leaderboard API routes. Verify `src/routes/leaderboard-api.ts` has both GET `/` and GET `/me` handlers.
  </verify>
  <done>
    Bot-facing JSON API available at `/api/v1/leaderboard` (full leaderboard) and `/api/v1/leaderboard/me` (agent's own rank). Both endpoints are behind auth middleware and rate limiter. Leaderboard API serves data from the same 30-minute cache as the web dashboard will use.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles with zero TypeScript errors
2. `tsconfig.json` contains `"jsx": "react-jsx"` and `"jsxImportSource": "hono/jsx"`
3. `src/config/env.ts` Zod schema includes `ADMIN_PASSWORD` as required string
4. `src/services/leaderboard.ts` exports `getLeaderboard`, `LeaderboardEntry`, `LeaderboardData`
5. `src/services/leaderboard.ts` uses Decimal.js for all financial arithmetic (no `Number()` on monetary values)
6. `src/services/leaderboard.ts` has thundering herd prevention (shared refreshPromise)
7. `src/routes/leaderboard-api.ts` exports `leaderboardApiRoutes` with GET `/` and GET `/me`
8. `src/index.ts` mounts leaderboard API AFTER auth middleware line
9. `src/index.ts` remains a `.ts` file (not `.tsx`)
</verification>

<success_criteria>
- TypeScript compiles cleanly with JSX support enabled
- Leaderboard service computes portfolio values using Jupiter prices + DB queries
- P&L uses the "money in vs money out" formula (Current Portfolio Value - Total Deposited)
- Cache singleton prevents redundant Jupiter API calls within 30-minute window
- Bot API returns JSON leaderboard data behind existing auth + rate limiting
- All financial math uses Decimal.js, formatted to 2 decimal places in output
</success_criteria>

<output>
After completion, create `.planning/phases/03-competition-dashboard/03-01-SUMMARY.md`
</output>
